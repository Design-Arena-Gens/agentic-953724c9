<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar-Powered Flying Wing</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F6FF 100%);
        }

        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }

        #info h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #FFD700;
        }

        #info p {
            margin: 8px 0;
            line-height: 1.6;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .stat-label {
            color: #FFD700;
        }

        .stat-value {
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="info">
        <h1>‚òÄÔ∏è Solar Flying Wing</h1>
        <div class="stat">
            <span class="stat-label">Altitude:</span>
            <span class="stat-value" id="altitude">5000 ft</span>
        </div>
        <div class="stat">
            <span class="stat-label">Speed:</span>
            <span class="stat-value" id="speed">120 mph</span>
        </div>
        <div class="stat">
            <span class="stat-label">Solar Power:</span>
            <span class="stat-value" id="power">850 W</span>
        </div>
        <div class="stat">
            <span class="stat-label">Battery:</span>
            <span class="stat-value" id="battery">92%</span>
        </div>
        <p style="margin-top: 15px; font-size: 12px; color: #AAA;">
            Advanced solar-powered flying wing with photovoltaic cells covering the entire upper surface.
        </p>
    </div>

    <div id="controls">
        üñ±Ô∏è Drag to rotate ‚Ä¢ üîç Scroll to zoom
    </div>

    <script type="module">
        // Simple 3D engine using Canvas 2D
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        // 3D Math utilities
        class Vector3 {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            rotateX(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const y = this.y * cos - this.z * sin;
                const z = this.y * sin + this.z * cos;
                return new Vector3(this.x, y, z);
            }

            rotateY(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const x = this.x * cos + this.z * sin;
                const z = -this.x * sin + this.z * cos;
                return new Vector3(x, this.y, z);
            }

            rotateZ(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const x = this.x * cos - this.y * sin;
                const y = this.x * sin + this.y * cos;
                return new Vector3(x, y, this.z);
            }

            project(distance) {
                const scale = distance / (distance + this.z);
                return {
                    x: this.x * scale + width / 2,
                    y: this.y * scale + height / 2,
                    scale: scale
                };
            }
        }

        // Flying wing geometry
        function createFlyingWing() {
            const vertices = [];
            const faces = [];
            const solarCells = [];

            // Wing shape - swept back flying wing
            const wingspan = 400;
            const chordRoot = 150;
            const chordTip = 40;
            const sweep = 0.4;

            // Create wing surface vertices
            const segments = 20;
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const y = (t - 0.5) * wingspan;
                const sweepOffset = Math.abs(t - 0.5) * wingspan * sweep;
                const chord = chordRoot + (chordTip - chordRoot) * Math.abs(t - 0.5) * 2;

                // Leading edge
                vertices.push(new Vector3(-chord / 2 + sweepOffset, y, -5));
                // Trailing edge
                vertices.push(new Vector3(chord / 2 + sweepOffset, y, 5));
            }

            // Create wing surface faces
            for (let i = 0; i < segments; i++) {
                const base = i * 2;
                // Top surface
                faces.push([base, base + 2, base + 3, base + 1]);
            }

            // Add solar cells on top surface
            for (let i = 0; i < segments; i++) {
                const t = i / segments;
                const y = (t - 0.5) * wingspan;
                const sweepOffset = Math.abs(t - 0.5) * wingspan * sweep;
                const chord = chordRoot + (chordTip - chordRoot) * Math.abs(t - 0.5) * 2;

                // Create solar cell grid
                const cellsPerRow = Math.floor(chord / 25);
                for (let j = 0; j < cellsPerRow; j++) {
                    const x = -chord / 2 + sweepOffset + (j / cellsPerRow) * chord;
                    solarCells.push({
                        center: new Vector3(x + 10, y, -3),
                        size: 18
                    });
                }
            }

            return { vertices, faces, solarCells };
        }

        const wing = createFlyingWing();

        // Camera and rotation
        let rotationX = 0.3;
        let rotationY = 0;
        let rotationZ = 0;
        let distance = 800;
        let autoRotate = true;

        // Mouse controls
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            autoRotate = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                rotationY += deltaX * 0.01;
                rotationX += deltaY * 0.01;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            distance += e.deltaY * 0.5;
            distance = Math.max(400, Math.min(1500, distance));
        });

        // Animation
        let time = 0;

        function drawSolarCell(projected, size, brightness) {
            ctx.fillStyle = `rgb(${40 + brightness * 20}, ${60 + brightness * 80}, ${100 + brightness * 100})`;
            ctx.fillRect(projected.x - size / 2, projected.y - size / 2, size, size);

            // Cell grid lines
            ctx.strokeStyle = `rgba(200, 200, 255, ${0.3 * brightness})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(projected.x - size / 2, projected.y - size / 2, size, size);

            // Reflective highlight
            if (brightness > 0.6) {
                ctx.fillStyle = `rgba(255, 255, 255, ${(brightness - 0.6) * 0.5})`;
                ctx.fillRect(projected.x - size / 2 + 2, projected.y - size / 2 + 2, size / 3, size / 3);
            }
        }

        function render() {
            // Clear
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, width, height);

            // Draw clouds
            drawClouds();

            // Update rotation
            if (autoRotate) {
                rotationY += 0.005;
            }
            time += 0.016;

            // Transform and project vertices
            const projectedVertices = wing.vertices.map(v => {
                let transformed = v.rotateX(rotationX)
                                  .rotateY(rotationY)
                                  .rotateZ(rotationZ);
                return transformed.project(distance);
            });

            // Draw wing faces
            wing.faces.forEach((face, idx) => {
                const avgZ = face.reduce((sum, i) => {
                    return sum + wing.vertices[i].rotateX(rotationX)
                                                  .rotateY(rotationY)
                                                  .rotateZ(rotationZ).z;
                }, 0) / face.length;

                if (avgZ > 0) return; // Back-face culling

                ctx.beginPath();
                face.forEach((vertexIndex, i) => {
                    const p = projectedVertices[vertexIndex];
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.closePath();

                // Lighting calculation
                const brightness = Math.max(0.3, 0.5 + Math.sin(rotationY) * 0.3);

                // Wing surface color
                ctx.fillStyle = `rgb(${200 * brightness}, ${200 * brightness}, ${220 * brightness})`;
                ctx.fill();

                ctx.strokeStyle = `rgba(100, 100, 150, 0.3)`;
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Draw solar cells
            wing.solarCells.forEach((cell, idx) => {
                const transformed = cell.center.rotateX(rotationX)
                                               .rotateY(rotationY)
                                               .rotateZ(rotationZ);

                if (transformed.z > 0) return; // Back-face culling

                const projected = transformed.project(distance);
                const brightness = Math.max(0.4, 0.7 + Math.sin(rotationY + idx * 0.1) * 0.3);
                const size = cell.size * projected.scale;

                if (size > 1) {
                    drawSolarCell(projected, size, brightness);
                }
            });

            // Update stats
            updateStats();

            requestAnimationFrame(render);
        }

        function drawClouds() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            const cloudOffset = (time * 20) % (width + 400);

            for (let i = 0; i < 5; i++) {
                const x = (i * 400 - cloudOffset) % (width + 400) - 200;
                const y = 100 + i * 80;

                ctx.beginPath();
                ctx.arc(x, y, 40, 0, Math.PI * 2);
                ctx.arc(x + 30, y - 10, 50, 0, Math.PI * 2);
                ctx.arc(x + 60, y, 40, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function updateStats() {
            const altitude = Math.floor(5000 + Math.sin(time * 0.3) * 200);
            const speed = Math.floor(120 + Math.sin(time * 0.5) * 10);
            const power = Math.floor(850 + Math.sin(time * 0.7) * 150);
            const battery = Math.floor(92 + Math.sin(time * 0.2) * 8);

            document.getElementById('altitude').textContent = altitude + ' ft';
            document.getElementById('speed').textContent = speed + ' mph';
            document.getElementById('power').textContent = power + ' W';
            document.getElementById('battery').textContent = battery + '%';
        }

        // Start animation
        render();
    </script>
</body>
</html>
